syntax = "proto3";

package seigr;

import "common.proto"; // Import ThreatLevel from common definitions

// Enum for the operational status of each segment
enum SegmentOperationStatus {
    SEGMENT_STATUS_UNDEFINED = 0;     // Undefined or unknown status
    SEGMENT_ACTIVE = 1;               // Segment is active and accessible
    SEGMENT_INACTIVE = 2;             // Segment is inactive or paused
    SEGMENT_ARCHIVED = 3;             // Segment is archived and not used in active processing
    SEGMENT_DECOMMISSIONED = 4;       // Segment is permanently retired
}

// Enum for the segment replication level
enum ReplicationLevel {
    REPLICATION_LEVEL_UNDEFINED = 0;  // Undefined replication level
    REPLICATION_LEVEL_LOW = 1;        // Low replication level
    REPLICATION_LEVEL_MEDIUM = 2;     // Medium replication level
    REPLICATION_LEVEL_HIGH = 3;       // High replication level
    REPLICATION_LEVEL_MAXIMUM = 4;    // Maximum replication level for critical data
}

// Message representing the detailed status of a segment during monitoring cycles
message SegmentStatus {
    string segment_hash = 1;                   // Unique identifier of the monitored segment
    ThreatLevel threat_level = 2;              // Current threat level of the segment
    bool integrity_check_passed = 3;           // Indicates if the last integrity check was successful
    int32 threat_count = 4;                    // Count of recorded threats for replication decisions
    int32 replication_count = 5;               // Number of active replicas for the segment
    string last_checked = 6;                   // Timestamp of the last integrity check
    map<string, string> metadata = 7;          // Metadata for additional monitoring details
    string last_updated_by = 8;                // ID of the last hyphen or user to update this segment
}

// Primary message for metadata about each segment in a `.seigr` file
message SegmentMetadata {
    int32 segment_index = 1;                   // Index of the segment in the file sequence
    int32 segment_size = 2;                    // Size of the segment in bytes
    string segment_hash = 3;                   // Hash of the segment for integrity verification
    SegmentOperationStatus status = 4;         // Status of the segment (e.g., ACTIVE, ARCHIVED)
    ReplicationLevel replication_level = 5;    // Replication level for this segment
    string creation_timestamp = 6;             // Timestamp when the segment was created
    string primary_link = 7;                   // Primary link to previous or next segment
    repeated string secondary_links = 8;       // Secondary or backup links for redundancy
    map<string, string> metadata = 9;          // Additional metadata for extensibility
    int32 access_frequency = 10;               // Frequency of access to this segment, for adaptive replication
    string last_accessed = 11;                 // Timestamp of the last access for demand tracking
    string integrity_level = 12;               // Level of integrity checks required (e.g., "HIGH", "MEDIUM")
}
