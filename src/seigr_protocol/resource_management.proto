syntax = "proto3";

package seigr;

// Enum to specify different types of resources being monitored
enum ResourceType {
    RESOURCE_UNDEFINED = 0;
    RESOURCE_CPU = 1;
    RESOURCE_MEMORY = 2;
    RESOURCE_DISK = 3;
    RESOURCE_BANDWIDTH = 4;
    RESOURCE_GPU = 5;
    RESOURCE_STORAGE = 6;                    // New type for disk storage separate from I/O
}

// Enum to specify different resource utilization states
enum ResourceState {
    RESOURCE_STATE_UNDEFINED = 0;
    RESOURCE_STATE_OPTIMAL = 1;              // New state for highly efficient usage
    RESOURCE_STATE_NORMAL = 2;
    RESOURCE_STATE_WARNING = 3;
    RESOURCE_STATE_CRITICAL = 4;
    RESOURCE_STATE_OVERLOADED = 5;
}

// Message for tracking individual resource usage data
message ResourceUsage {
    ResourceType type = 1;
    double usage_percentage = 2;
    double absolute_usage = 3;
    string unit = 4;
    string hyphen_id = 5;
    string timestamp = 6;
    ResourceState state = 7;
    map<string, string> usage_metadata = 8;
    string application_id = 9;
    double temperature = 10;                 // Temperature of the hardware resource
    double resource_efficiency_score = 11;   // Efficiency score of resource usage
}

// Message for defining resource limits, aiding in threshold-based monitoring
message ResourceLimits {
    ResourceType type = 1;
    double warning_threshold = 2;
    double critical_threshold = 3;
    double absolute_max = 4;
    string unit = 5;
    bool enforce_limits = 6;
    string escalation_contact = 7;
    int32 max_continuous_overload_seconds = 8;
    string auto_scale_action = 9;            // Auto-scaling action to take upon overload
    double usage_decay_rate = 10;            // Expected rate of recovery to normal usage
}

// Message for managing the configuration of resource monitoring across the network
message ResourceMonitorConfig {
    int32 check_interval_seconds = 1;
    repeated ResourceLimits resource_limits = 2;
    bool enable_alerting = 3;
    map<string, string> config_metadata = 4;
    string alert_protocol = 5;
    int32 grace_period_seconds = 6;
    int32 auto_scale_threshold = 7;
    map<string, int32> alert_severity_levels = 8; // Severity levels for different resource types, using string keys
    int32 alert_frequency_limit = 9;           // Max alerts per time unit to avoid alert fatigue
}

// Message for aggregating usage statistics over a specified monitoring period
message ResourceUsageSummary {
    ResourceType type = 1;
    string hyphen_id = 2;
    double average_usage = 3;
    double peak_usage = 4;
    double minimum_usage = 5;
    double usage_standard_deviation = 6;
    string summary_period = 7;
    int32 threshold_exceed_count = 8;
    double cost_estimate = 9;                 // Financial estimate of resource usage
    int32 time_above_threshold = 10;          // Time spent above critical threshold
}

// Message for tracking the resource status of all hyphens within a network cluster
message ClusterResourceStatus {
    string cluster_id = 1;
    repeated ResourceUsageSummary hyphen_summaries = 2;
    map<string, double> cluster_average_usage = 3;
    map<string, double> cluster_peak_usage = 4;
    string last_updated = 5;
    string health_status = 6;
    int32 overloaded_hyphens_count = 7;
    string recovery_action_plan = 8;
    double cluster_utilization_score = 9;
    map<string, string> metadata = 10;
    double load_distribution_score = 11;       // Efficiency score for load distribution across hyphens
    string alert_escalation_path = 12;         // Escalation contacts for cluster-wide degradation
}
